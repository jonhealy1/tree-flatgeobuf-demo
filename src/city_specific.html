<!DOCTYPE html>
<html lang="en">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <link href="https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@2.1.9/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/flatgeobuf@3.22.0/dist/flatgeobuf-geojson.min.js"></script>
    <style>
        #map { height: 100vh; }
    </style>
</head>
<body>
    <div id="map"></div>
    <script type="module">
        const map = new maplibregl.Map({
            container: "map",
            style: "https://api.maptiler.com/maps/backdrop/style.json?key=6jk9aonLicRFoRqvljrc",
            center: [-114.0719, 51.0447], // Starting at Calgary
            zoom: 4,
            maxZoom: 20,
        });

        const cityBounds = {
            'Calgary': { minX: -114.316, minY: 50.842, maxX: -113.859, maxY: 51.212 },
            'Vancouver': { minX: -123.224, minY: 49.198, maxX: -123.022, maxY: 49.316 },
            'Edmonton': { minX: -113.718, minY: 53.413, maxX: -113.278, maxY: 53.657 }
        };

        let currentCity = null;

        function isInsideCity(center, cityName) {
            const bounds = cityBounds[cityName];
            return center.lng >= bounds.minX && center.lng <= bounds.maxX &&
                   center.lat >= bounds.minY && center.lat <= bounds.maxY;
        }

        async function updateResults() {
            const center = map.getCenter();
            const zoom = map.getZoom();
            let newCity = null;

            if (zoom > 10) {
                if (isInsideCity(center, 'Calgary')) {
                    newCity = 'Calgary';
                } else if (isInsideCity(center, 'Vancouver')) {
                    newCity = 'Vancouver';
                } else if (isInsideCity(center, 'Edmonton')) {
                    newCity = 'Edmonton';
                }
            }

            if (newCity !== currentCity) {
                currentCity = newCity;
                if (currentCity) {
                    const url = `https://cif-canada.s3.amazonaws.com/flatgeobuf/${currentCity.toLowerCase()}_no_index.fgb`;
                    const fc = { type: "FeatureCollection", features: [] };
                    const iter = flatgeobuf.deserialize(url);
                    for await (let feature of iter) {
                        fc.features.push(feature);
                    }
                    if (map.getSource("points")) {
                        map.getSource("points").setData(fc);
                    } else {
                        map.addSource("points", {
                            type: "geojson",
                            data: fc,
                            cluster: true,
                            clusterMaxZoom: 14,
                            clusterRadius: 50
                        });

                        // ... Add layers for clusters and unclustered points here ...
                    }
                } else {
                    // Clear data when zooming out of city bounds
                    if (map.getSource("points")) {
                        map.getSource("points").setData({ type: "FeatureCollection", features: [] });
                    }
                }
            }
        }

        map.on("load", () => {
            updateResults();
            map.on("moveend", updateResults);
        });
    </script>
</body>
</html>
